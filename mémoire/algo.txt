model modelBasic.mod;
data graph.dat
drop eq24;
drop eq25;


#================
#Building sets for connectivity cuts
#================

let FEASIBLE := FEASIBLE union {1};
repeat while card(FEASIBLE)>0{
	solve;
	display allocated;
	drop eq24;
	drop eq25;
	drop eq26;
	let FEASIBLE := {} ; 
	for {j in FEEDERS}{
		let N[j]:= {};
		let CC[j]:={};
		let CS[j]:= {};
		for { i in CLIENTS}{
			let C[j,i]:={};
			let C_MIN_DISTANCE_CLIENT[j,i]:={};
			let CS_RELEVANT_FOR_CC[j,i]:={};
			if allocated[j,i] then{
				let N[j]:=N[j] union {i};
			}
		}
	}
	#let TREATED := {};
	for {j in FEEDERS}{
		for {n in NEIGHBOURS[j]}{
			if n in N[j] then{
				let CC[j] := CC[j] union {n};	
				let DIST_TO_FEEDER[j,n]:= {1};			
			}
		}
		for {v in CC[j]}{
			for {n in NEIGHBOURS[v]}{
				if n in N[j] then{
					if n not in CC[j] then{
						let CC[j]:=CC[j] union {n};
						let DIST_TO_FEEDER[j,n]:=DIST_TO_FEEDER[j,v] union {1};	
					}
				}
				else if n in CLIENTS then{
					let CS[j]:=CS[j] union {n};
				}
			}
		}
		let O[j] := N[j] diff CC[j];
		
		#true if set of customers allocated to feeder j is not connected
		if card(O[j])>0 then {
			restore eq24;
			restore eq25;
			let FEASIBLE := FEASIBLE union {1};
			let C_FIRST_CLIENTS[j] := {};
			let TREATED := {};
			for {v in O[j]}{
				if v not in TREATED then {
					let C_FIRST_CLIENTS[j]:=C_FIRST_CLIENTS[j] union {v};
					let C[j,v] := C[j,v] union {v};
					for {k in C[j,v]}{
						for {n in NEIGHBOURS[k]}{
							if n in O[j] and n not in C[j,v]then {
								let C[j,v]:=C[j,v] union {n};
								let TREATED := TREATED union {n};
							}
						}
					}	
				}
			}
			#preparing CS for eq25
			for {v in C_FIRST_CLIENTS[j] }{
				let C_MIN_DISTANCE_CLIENT[j,v] := C_MIN_DISTANCE_CLIENT[j,v] union {v};
			}
			#display C_MIN_DISTANCE_CLIENT;
			#choosing closest client to feeder for every connected component in O[j]
			for {v in C_FIRST_CLIENTS[j],c in C[j,v],i_cc in C_MIN_DISTANCE_CLIENT[j,v] }{
				#display i_cc;
				#display c;
				if hopcost[j,c] < hopcost[ j , i_cc ] then {
					let C_MIN_DISTANCE_CLIENT[j,v] := C_MIN_DISTANCE_CLIENT[j,v] diff C_MIN_DISTANCE_CLIENT[j,v];
					let C_MIN_DISTANCE_CLIENT[j,v]:= C_MIN_DISTANCE_CLIENT[j,v] union {c};
				}
			}
			for {v in C_FIRST_CLIENTS[j], i_cc in C_MIN_DISTANCE_CLIENT[j,v], k in CS[j]}{
				if (hopcost[j,k]+ hopcost[i_cc,k])<= max_distance then
					let CS_RELEVANT_FOR_CC[j,v] := CS_RELEVANT_FOR_CC[j,v] union {k};
			}
		}
		
		
		#true if set of customers allocated to feeder j is connected
		if card(O[j])=0 then {
			#preparing set F 
			let F[j]:= {};
			for {i in CC[j]}{
				if card(DIST_TO_FEEDER[j,i]) = max_distance+1 then {
					let F[j] := F[j] union {i};
				}
			}
			if card(F[j]) > 0 then {	
				restore eq26;	
				let FEASIBLE := FEASIBLE union {1};
				for {i in F[j]}{
					let CS_RELEVANT_FOR_CLIENT_IN_F[j,i]:={};
				}
				for {i in F[j],k in CS[j]}{
					if hopcost[j,k]+hopcost[k,i]<=max_distance then{
						let CS_RELEVANT_FOR_CLIENT_IN_F[j,i]:=CS_RELEVANT_FOR_CLIENT_IN_F[j,i] union {k};
					}
				}
			}
		}
	}
};
